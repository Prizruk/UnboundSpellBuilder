@page "/spellbuilder"
@inject HttpClient Http

<PageTitle>Spell Builder</PageTitle>

@{
    var showChoice = isChoosing ? "d-block" : "d-none";
    var showInfo = isChoosing ? "d-none" : "d-block";
}

<h1>Spell Builder</h1>

<div class="spellChoice p-3 @showChoice" id="spellChoice">
    @if (effects != null){
        @foreach(var effect in effects)
        {
            @if(!effect.unique || spellHasEffect(effect) == -1)
            {
                <button class="btn btn-primary" @onclick="(args)=> AddEffect(args, effect.name)"><Tooltip Text=@effect.help>@effect.name</Tooltip></button>
            }
        }
    }
    <br><br><br>
    <button class="btn btn-primary" @onclick="(args)=>{isChoosing = false;}"><Tooltip Text="Cancel adding an effect">Cancel</Tooltip></button>

</div><br>
<div class="spellInfo p-3 @showInfo" id="spellInfo">
    @if(effects == null)
    {
        <p><em>Loading...</em></p>
    }
    else
    {
        <table class="table" style="table-layout: fixed ; width: 100%;">
            <thead>
                <tr>
                    <th>Character Stats</th>
                    <th>Spell Stats</th>
                    <th>Spell Keywords</th>
                    <th>Spell Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td> 
                        <div>
                            <table align="left" style="width: 100%;">
                                <tbody>
                                <tr>
                                    <td><Tooltip Text="Your MAG value, not mod">MAG:</Tooltip></td><td><input style="width: 25%;" type="number" name="MAG" min="0" max="99" @bind="@MAGvalue" @oninput="@((e) => {UpdateParams((string)e.Value,1);})"></td>
                                </tr>
                                <tr>
                                    <td><Tooltip Text="Your THM value, not mod">THM:</Tooltip></td><td><input style="width: 25%;" type="number" name="THM" min="0" max="99" @bind="@THMvalue" @oninput="@((e) => {UpdateParams((string)e.Value,2);})"></td>
                                </tr>
                                </tbody>
                            </table><br>           
                            <table align="left">
                                <tr><th></th><th>Talents:</th></tr>
                                <tr>
                                    <td><input type="checkbox" name="destructiveCheck" @bind="@hasDestructive" @oninput="@((e) => {UpdateBools(e.Value,1);})" ></td><td><Tooltip Text="Increases damage die of all destructive spells by one step">Destructive Spells</Tooltip></td>
                                </tr>
                            </table>
                        </div>
                    </td>
                    <td>
                        <table align="left" style="width: 100%;">
                            <tr>
                                <td>EMM bonus:</td><td><input style="width: 25%;" type="number" name="EMMB" min="0" max="99" @bind="@EMMB" @oninput="@((e) => {UpdateParams((string)e.Value,3);})"></td>
                            </tr>
                            <tr>
                                <td>Spell Level:</td><td><input style="width: 25%;" type="number" name="level" min="0" max="6" @bind="@spell.level" @oninput="@((e) => {UpdateParams((string)e.Value,4);})"></td>
                            </tr>
                        </table>
                    </td>
                    <td>
                        @foreach(var effect in spell.effects)
                        {
                            @effect.GetName()<br>
                        }                                    
                    </td>
                    <td>
                        <b>School:</b> @spell.school<br>
                        <b>Level:</b> @spell.level<br>
                        <b>Spellpoints:</b> @spell.pointcost / @spell.pointmax<br>
                        <b>Mana:</b> @spell.manacost<br>
                        <b>Cast DC:</b> @spell.castDC<br>
                        <hr>
                        @spell.effect
                    </td>
                </tr>
            </tbody>
        </table>
    }
    <br><br>
    @if (spell.effects.Count == 0 || spell.effects.Count < spell.level)
    {
        <button class="btn btn-primary" @onclick="(args) => ToggleAddingEffects(args)"><Tooltip Text="Add an Effect or Condition to the spell">Add Effect</Tooltip></button>
    }
    <br><br>
    <button class="btn btn-primary" @onclick="(args) => ClearSpell(args)">Clear Spell</button>
</div>

@code 
{
    private EffectKeyword[]? effects;
    private Spell spell = new Spell();
    [Parameter]
    public bool isChoosing { get; set; }
    public bool hasDestructive { get; set; }
    public int MAGvalue { get; set;} = 10;
    public int THMvalue { get; set;} = 10;
    public int EMMB{ get; set;} = 0;

    public class Spell
    {
        public string school;
        public int level;
        public int pointcost;
        public int pointmax;
        public int manacost;
        public int castDC;
        public string effect;
        public List<EffectKeyword> effects;

        public Spell()
        {
            this.school = "?";
            this.level = 0;
            this.pointcost = 0;
            this.manacost = 0;
            this.castDC = 10;
            this.effect = "?";
            this.pointmax = 3;
            this.effects = new List<EffectKeyword>();
        }
    }

    public class Keyword
    {
        public string name { get; set; }
        public string help { get; set; }
        public string school { get; set; }
        public int level { get; set; }
        public int cost { get; set; }
        public bool unique {get; set; }
        public int ammount {get; set; }


        public Keyword()
        {
            this.cost = 0;
            this.help = "";
            this.level = 0;
            this.name = "";
            this.school = "";
            this.unique = false;
            this.ammount = 0;
        }
    }

    public class EffectKeyword : Keyword
    {
        public string description { get; set; }
        public List<EffectModifier> modifiers;
        public EffectKeyword()
        {
            this.cost = 99;
            this.description = "www";
            this.help = "wow";
            this.level = 99;
            this.name = "wow";
            this.school = "wow";
            this.unique = false;
            this.ammount = 0;
            this.modifiers = new List<EffectModifier>();
        }

        public EffectKeyword Clone()
        {
            EffectKeyword newEffect = new EffectKeyword();
            newEffect.cost = this.cost;
            newEffect.description = this.description;
            newEffect.help = this.help;
            newEffect.level = this.level;
            newEffect.name = this.name;
            newEffect.school = this.school;
            newEffect.unique = this.unique;
            newEffect.ammount = this.ammount;
            return newEffect;
        }

        public string GetName()
        {
            string desc = this.name;
            if (this.ammount > 1)
                desc += " x" + this.ammount.ToString();
            if (this.modifiers.Count > 0){
                desc += " (";
                foreach(EffectModifier mod in this.modifiers)
                {
                    desc += mod.name;
                    if (mod.ammount > 0)
                        desc += " x" + mod.ammount.ToString();
                    desc += ",";
                }
                desc += desc.Remove(desc.LastIndexOf(",")) + ")";
            }
            return desc;
        }

    }

    public class EffectModifier : Keyword
    {
        public EffectModifier()
        {
            this.cost = 0;
            this.help = "";
            this.level = 0;
            this.name = "";
            this.school = "";
            this.unique = false;
            this.ammount = 0;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        isChoosing = false;
        effects = await Http.GetFromJsonAsync<EffectKeyword[]>("sample-data/effects.json");
    }

    private string DoMult(string orig)
    {
        int startMult = orig.IndexOf("%mult%");
        int endMult = orig.IndexOf("%/mult%",startMult);
        string[]? forMult = orig.Substring(startMult,endMult-startMult).Replace("%mult%","").Replace("%/mult%","").Split(";");
        int answer = 1;
        foreach(string mult in forMult)
            answer *= System.Convert.ToInt32(mult);
        orig = orig.Remove(startMult, endMult - startMult).Replace("%/mult%","").Insert(startMult,answer.ToString());
        return orig;
    }

    private string DoQuad(string orig, int level)
    {
        int startQuad = orig.IndexOf("%quad%");
        int endQuad = orig.IndexOf("%/quad%",startQuad);
        string[]? forQuad = orig.Substring(startQuad,endQuad-startQuad).Replace("%quad%","").Replace("%/quad%","").Split(";");
        double answer = Math.Round(System.Convert.ToDouble(forQuad[0])*Math.Pow(level,2) + System.Convert.ToDouble(forQuad[1])*level + System.Convert.ToDouble(forQuad[2]));
        orig = orig.Remove(startQuad, endQuad - startQuad).Replace("%/quad%","").Insert(startQuad,answer.ToString());
        return orig;
    }

    private string DoLevelDepend(string orig, int level)
    {
        string rem, kep;
        if (level == 0)
        {   rem = "l+"; kep = "l0"; }
        else
        {   rem = "l0"; kep = "l+"; }
        int rs,re;
        while (orig.Contains("%"+rem+"%"))
        {
            rs = orig.IndexOf("%"+rem+"%");
            re = orig.IndexOf("%/"+rem+"%")+("%/"+rem+"%").Length;
            orig = orig.Remove(rs,re-rs);
        }
        orig = orig.Replace("%"+kep+"%","").Replace("%/"+kep+"%","");
        return orig;
    }

    private string IncreaseDie(string die)
    {
        switch(die)
        {
            case "d4": die = "d6"; break;
            case "d6": die = "d8"; break;
            case "d8": die = "d10"; break;
            case "d10": die = "d12"; break;
            case "d12": if(hasDestructive) die = "2d6"; break;
            default: break;
        }
        return die;
    }

    private string DecreaseDie(string die)
    {
        switch(die)
        {
            case "d6": die = "d4"; break;
            case "d8": die = "d6"; break;
            case "d10": die = "d8"; break;
            case "d12": die = "d10"; break;
            case "2d6": die = "d12"; break;
            default: break;
        }
        return die;
    }

    private string DoDam(string orig)
    {
        int ds = orig.IndexOf("%d%");
        int de = orig.IndexOf("%/d%",ds);
        string dice = orig.Substring(ds,de-ds).Replace("%d%","");
        Console.WriteLine(dice + " " + hasDestructive);
        if (hasDestructive)
            dice = IncreaseDie(dice);
        orig = orig.Remove(ds,de-ds+"%/d%".Length).Insert(ds,dice);      
        return orig;
    }

    private void UpdateSpellEffect(Spell spell)
    {
        if (spell.effect.Contains("%EMM%")) spell.effect = spell.effect.Replace("%EMM%",((MAGvalue-10)/2+EMMB).ToString());
        if (spell.effect.Contains("%lvl%")) spell.effect = spell.effect.Replace("%lvl%",spell.level.ToString());
        if (spell.effect.Contains("%lvlm%")) spell.effect = spell.effect.Replace("%lvlm%",Math.Max(spell.level,1).ToString());
        if (spell.effect.Contains("%l0%")) spell.effect = DoLevelDepend(spell.effect,spell.level);
        while (spell.effect.Contains("%d%")) spell.effect = DoDam(spell.effect);
        while (spell.effect.Contains("%quad%")) spell.effect = DoQuad(spell.effect,spell.level);
        while (spell.effect.Contains("%mult%")) spell.effect = DoMult(spell.effect);
    }

    private EffectKeyword returnEffectByName(string effectname)
    {
        if (effects != null)
        {
            foreach(EffectKeyword effect in effects)
                if (effect.name == effectname)
                    return effect;
        }
        return null;
    }

    private int spellHasEffect(EffectKeyword effect)
    {
        if (spell.effects == null)
            return -1;
        for(int i = 0; i < spell.effects.Count; i++)
            if (spell.effects[i].name == effect.name)
                return i;
        return -1;
    }

    private async Task AddEffect(MouseEventArgs e, string effectname)
    {
        EffectKeyword newEffect = returnEffectByName(effectname).Clone();
        if (newEffect == null)
            return;
        int ei = spellHasEffect(newEffect);
        if (ei > -1)
            spell.effects[ei].ammount += 1;
        else
            spell.effects.Add(newEffect);
        UpdateSpellInfo();
        isChoosing = false;
    }

    private async Task ToggleAddingEffects(MouseEventArgs e)
    {
        isChoosing = true;
    }

    private async Task UpdateParams(string value, int type)
    {
        int newValue = System.Convert.ToInt32(value);
        switch(type)
        {
            case 1: MAGvalue = newValue; break;
            case 2: THMvalue = newValue; break;
            case 3: EMMB = newValue; break;
            case 4: spell.level = newValue; break;
            default: return;
        }
        UpdateSpellInfo();
    }

    private async Task UpdateBools(object value, int type)
    {
        bool newValue = System.Convert.ToBoolean(value);
        switch(type)
        {
            case 1: hasDestructive = newValue; break;
            default: return;
        }
        UpdateSpellInfo();
    }

    private async Task UpdateSpellInfo()
    {   
        if (spell.effects.Count == 0)
            return;
        while (spell.effects.Count > Math.Max(1,spell.level))
            spell.effects.Remove(spell.effects.Last());
        spell.pointcost = spell.effects[0].cost;
        spell.pointmax = 3+spell.level;
        spell.manacost = 5*spell.level;
        spell.school = spell.effects[0].school;
        spell.castDC = 10+4*spell.level;
        spell.effect = spell.effects[0].description;
        UpdateSpellEffect(spell);                
        InvokeAsync(StateHasChanged);
    }

    private async Task ClearSpell(MouseEventArgs e)
    {
        spell = new Spell();
    }

}
